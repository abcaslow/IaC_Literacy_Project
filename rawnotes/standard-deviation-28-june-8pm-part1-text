Standard Deviation Part One of Two

Standard Deviation shows you the spread of the data. It shows you how consistent data measurements are. Consider the following two data sets:
    
    50,50,50,50= mean (50), std=0
    10,90,40,60= mean (50), std= 29.15475

np.array_equal(x,y)

Try out the np.allclose() method. VERY POWERFUL
In [452]: z
Out[452]: array([10, 90, 40, 60])

In [453]: z1
Out[453]: array([15, 90, 40, 60])

In [454]: np.allclose(z,z1,atol=5.0)
Out[454]: True

atol=absolute tolerance

In [455]: np.allclose(z,z1,atol=4.9)
Out[455]: False

https://towardsdatascience.com/12-amazing-pandas-numpy-functions-22e5671a45b8

Finally, for an element by element comparision, use z==z1 without or without the .any and .all options.

In [470]: z
Out[470]: array([10, 90, 40, 60])

In [471]: z1
Out[471]: array([15, 90, 40, 60])

Use the np.count_nonzero() method to count the number of True elements in an array:

In [473]: z==z1
Out[473]: array([False,  True,  True,  True])

In [472]: np.count_nonzero(z==z1)
Out[472]: 3

https://www.kite.com/python/answers/how-to-count-the-number-of-true-elements-in-a-numpy-boolean-array-in-python

Using Python and numpy to understand standard deviation.

You need data to calculate an average/mean.
You need data and a mean and a variance to calculate a standard deviation.

The Standard Deviation is a measure of how spread out numbers are.
Its symbol is Ïƒ (the greek letter sigma)
The formula is easy: it is the square root of the Variance. 
The average of the squared differences from the Mean.

Source: https://www.mathsisfun.com/data/standard-deviation.html

Remember to always start with calculating the mean first, then callculate the standard deviation.

Degrees of Freedom

When configuring the standard deviation ith numpy, remember the degrees of freedom option (ddof):

np.std(n, ddof=1)

Degrees of Freedom impacts the denominator of a variance or standard deviations. The denominator can be either n (a degree of freedom of 0) or n-1 (a degree of freedom of 1). 

https://www.statsdirect.com/help/basics/degrees_of_freedom.htm
https://onlinestatbook.com/2/estimation/df.html

More on the Degrees of Freedom:
    
 Note in the example above that we are dividing by N, not N-1 as is usually seen in standard deviation calculations. When the standard deviation is computed using all values in the population, N is used as the divisor. However, when the standard deviation is calculated from a sample, N-1 is used as the divisor. We stress that the results for a sample by using the lower-case n and naming the sample standard deviation.......The n-1 is used instead of n to correct for bias that statisticians have discovered. That is, over the long run, dividing by n-1 provides a better estimate of the true standard deviation than does dividing by n. Although we divide by n-1 rather than n for sample standard deviations, we recommend that for purposes of interpretation, the divisor is assumed to be n, so that the operation can be thought of as computing an average.

From Stack Exchange to reflect a histogram of rolling two dice (BEAUTIFUL!)
   
N = int(1e5)
A = np.random.randint(low=1, high=7, size=N)
B = np.random.randint(low=1, high=7, size=N)
dice = A + B
plt.hist(dice, bins=np.arange(2, 14), align="left", rwidth=0.9)
plt.show()

Source: https://stackoverflow.com/questions/55897323/plot-a-histogram-of-the-sum-of-rolling-two-die
 
numbers=[100,100]*100
numbers
import numpy as np
np.array(numbers)
x=np.array(numbers)
np.std(x)
numbers=[100,102]*50
x=np.array(numbers)
x
np.std(x)
numbers=[100,101]*50
x=np.array(numbers)
x
np.std(x)
numbers=[99,100,101]*33
x
history
x
numbers=[99,100,101]*33
numbers
x=np.array(numbers)
x
np.std(x)
history

x=[1,1,1,1]+[2,2,2,2]+[3,3,3,3]+[4,4,4,4]
na=np.array(n)
np.mean(n)
np.std(n)

=======================
https://www.mathsisfun.com/data/standard-deviation.html
?%history
%history -g -f test-ipython-history-log



